[Вернуться][main]

---

# Основы Python Celery

[Celery][celery] - это распределённая очередь задач, которая может собирать, записывать, планировать и выполнять
задачи вне вашей основной программы.

> Примечание: Celery отказался от поддержки Windows в версии 4, поэтому, хотя вы всё ещё можете заставить его работать
> под Windows, лучше использовать другую очередь задач, например huey или Dramatiq.

Чтобы получать задания от вашей программы и отправлять результаты в бэкэнд, `Celery` требуется брокер сообщений для
взаимодействия. `Redis` и `RabbitMQ` - два брокера сообщений, которые разработчики часто используют вместе с `Celery`.

В этом семинаре мы будем использовать [Redis][redis] в качестве брокера сообщений. Про использование
[RabbitMQ][rabbitmq] скорее всего поведают в одном из будущих семинаров.

## Зачем использовать Celery?

Есть две основные причины, по которым большинство разработчиков хотят начать использовать Celery:

- Разгрузка работы вашего приложения на распределенные процессы, которые могут работать независимо от вашего приложения.
- Планирование выполнения задач в определенное время, иногда в виде повторяющихся событий.

Celery - отличный выбор для обоих этих случаев использования. Он определяет себя как "очередь задач с фокусом на
обработку в реальном времени, а также с поддержкой планирования задач".

Несмотря на то, что обе эти функции являются частью Celery, их часто рассматривают отдельно:

- **Celery workers** - это рабочие процессы, которые выполняют задачи независимо друг от друга и вне контекста вашего
  основного сервиса.
- **Celery beat** - это планировщик, который определяет время выполнения задач. Вы можете использовать его и для
  планирования периодических задач.

Celery workers - это основа Celery. Даже если вы планируете периодические задачи с помощью Celery beat, воркер Celery
подхватит ваши инструкции и выполнит их в назначенное время. Что добавляет Celery beat в этот микс, так это планировщик
на основе времени для рабочих Celery.

В этом семинаре вы узнаете, как интегрировать Celery с Django, чтобы выполнять операции асинхронно из основного потока
выполнения вашего приложения с помощью Celery workers.

В этом семинаре вы не будете рассматривать планирование задач с помощью Celery beat, но как только вы поймете основы
задач Celery, вы будете хорошо подготовлены к настройке периодических задач с помощью Celery beat.

## Как вы можете использовать Celery для вашего Django-приложения?

Celery полезен не только для веб-приложений, но он, безусловно, популярен в этом контексте. Это связано с тем, что вы
можете эффективно решать некоторые повседневные ситуации в веб-разработке, используя распределенную очередь задач, такую
как Celery:

- **Отправка электронной почты**: Может понадобиться отправить письмо с проверкой электронной почты, письмо для
  сброса пароля или подтверждение отправки формы. Отправка электронных писем может занять много времени и замедлить
  работу вашего приложения, особенно если у него много пользователей.

- **Обработка изображений**: Может понадобиться изменить размер изображений аватаров, загружаемых пользователями,
  или применить кодировку ко всем изображениям, которыми пользователи могут поделиться на вашей платформе. Обработка
  изображений часто является ресурсоемкой задачей, которая может замедлить работу вашего веб-приложения, особенно если
  вы обслуживаете большое количество пользователей.

- **Обработка текста**: Если вы разрешаете пользователям добавлять данные в ваше приложение, то, возможно, захочется
  контролировать их ввод. Например, вы можете захотеть проверить наличие ненормативной лексики в комментариях или
  перевести отправленный пользователем текст на другой язык. Выполнение всей этой работы в контексте вашего
  веб-приложения может значительно снизить производительность.

- **Вызовы API и другие веб-запросы**: Если необходимо выполнять веб-запросы для предоставления услуг, которые
  предлагает ваше приложение, то вы можете быстро столкнуться с непредвиденным временем ожидания. Это касается как
  API-запросов с ограничением скорости, так и других задач, например, веб-скреппинга. Часто лучше передать эти запросы
  другому процессу.

- **Анализ данных**: Анализ данных, как известно, требует много ресурсов. Если ваше веб-приложение анализирует данные
  для ваших пользователей, вы быстро увидите, что ваше приложение не реагирует на запросы, если вы выполняете всю работу
  прямо в Django.

- **Запуск моделей машинного обучения**: Как и в случае с другим анализом данных, ожидание результатов операций
  машинного обучения может занять некоторое время. Вместо того чтобы заставлять пользователей ждать завершения
  вычислений, вы можете переложить эту работу на Celery, чтобы они могли продолжать просматривать ваше веб-приложение,
  пока не появятся результаты.

- **Генерация отчетов**: Если вы используете приложение, позволяющее пользователям генерировать отчеты на основе
  предоставленных ими данных, вы заметите, что создание PDF-файлов не происходит мгновенно. Пользователи получат больше
  удовольствия, если вы позволите Celery заниматься этим в фоновом режиме, а не замораживать ваше веб-приложение до тех
  пор, пока отчет не будет готов к загрузке.

Основная настройка для всех этих различных сценариев использования будет схожей. Как только вы поймете, как передать
вычислительные или трудоемкие процессы в распределенную очередь задач, вы освободите Django для обработки цикла
HTTP-запросов-ответов.

В этом семинаре вы рассмотрите сценарий отправки электронной почты. Вы начнете с проекта, в котором Django обрабатывает
отправку электронной почты синхронно. Вы проведете тест, чтобы увидеть, как это заморозит ваше приложение Django. Затем
вы узнаете, как переложить эту задачу на Celery, чтобы увидеть, как это заставит ваше веб-приложение реагировать гораздо
быстрее.

---

[Вернуться][main]


[main]: ../../README.md "содержание"

[celery]: https://docs.celeryq.dev/en/stable/index.html "celery"
[redis]: https://redis.io/ "redis"
[rabbitmq]: https://www.rabbitmq.com/ "rabbitmq"
